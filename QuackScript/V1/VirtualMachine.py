import pickle
import os
from MemoryManager import MemoryManager


class QuackVirtualMachine:
    """
    A simple virtual machine to execute QuackScript programs.
    It reads object files generated by the QuackCompiler
    and translates them into a format that can be executed.
    """

    def __init__(self):
        """
        Initializes the Quack Virtual Machine.
        """
        # self.symbol_table = None
        self.quadruples = None
        self.memory_manager = None
        self.operators = None
        self.constant_table = None
        self.functions = None
        self.global_container_name = None

    def read_and_delete_object_files(self, file_name):
        # print(f"Reading object file: {file_name}")
        with open(file_name, "rb") as f:
            data = pickle.load(f)
        os.remove(file_name)
        return data

    def display_quads(self):
        """
        Displays the quadruples in a readable format.
        """
        # Flip the operators dictionary for better readability
        ops = {v: k for k, v in self.operators.items()}

        for i, quad in enumerate(self.quadruples):
            op, arg1, arg2, result = quad
            op_str = ops.get(op, op)
            print(f"{i}: ({op_str}, {arg1}, {arg2}, {result})")

    def process_quadruples(self):
        """
        Processes the quadruples and executes them.
        This method should be implemented to handle the execution logic.
        """
        current_pos = 0
        quadruple = (None, None, None, None)

        self.display_quads()
        print("\n\n\n\n")

        while quadruple[0] != self.operators["end"]:
            quadruple = self.quadruples[current_pos]
            op, arg1, arg2, result = quadruple
            # print(f"{current_pos}: {(op, arg1, arg2, result)}")

            value1 = self.memory_manager.get_memory(arg1) if arg1 is not None else None
            value2 = self.memory_manager.get_memory(arg2) if arg2 is not None else None

            if op == self.operators["+"]:
                result_value = value1 + value2
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["-"]:
                result_value = value1 - value2
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["*"]:
                result_value = value1 * value2
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["/"]:
                if value2 == 0:
                    print("Error: Division by zero.")
                    break
                result_value = value1 / value2
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["<"]:
                result_value = value1 < value2
                result_value = int(result_value)  # Convert boolean to int
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["<="]:
                result_value = value1 <= value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators[">"]:
                result_value = value1 > value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators[">="]:
                result_value = value1 >= value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["=="]:
                result_value = value1 == value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["and"]:
                result_value = value1 and value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            elif op == self.operators["or"]:
                result_value = value1 or value2
                result_value = int(result_value)
                self.memory_manager.set_memory(index=result, value=result_value)
            if op == self.operators["goto"]:
                current_pos = result
            elif op == self.operators["gotoF"]:
                if not bool(value1):
                    current_pos = result
            elif op == self.operators["gotoT"]:
                if bool(value1):
                    current_pos = result
            elif op == self.operators["="]:
                self.memory_manager.set_memory(index=result, value=value1)
            elif op == self.operators["print"]:
                value = self.memory_manager.get_memory(result)
                print(value)

            # if op == self.operators["="]:
            #     self.memory_manager.set_memory()

            if op == self.operators["end"]:
                print("End of program.")
                break

            # Update current index
            current_pos += 1

    def reconstruct_memory(self):
        """ "
        Reconstructs the memory manager and constant table.
        """
        constants_required_space = self.constant_table.required_space
        global_required_space = self.functions[self.global_container_name].required_space

        self.memory_manager = MemoryManager(
            {
                "global": {
                    "int": ((1000, 1999), global_required_space.get("int", 0)),
                    "float": ((2000, 2999), global_required_space.get("float", 0)),
                    "t_int": ((3000, 3999), global_required_space.get("t_int", 0)),
                    "t_float": ((4000, 4999), global_required_space.get("t_float", 0)),
                    "t_bool": ((5000, 6999), global_required_space.get("t_bool", 0)),
                },
                "constant": {
                    "int": ((12000, 12999), constants_required_space.get("int", 0)),
                    "float": ((13000, 13999), constants_required_space.get("float", 0)),
                    "str": ((14000, 14999), constants_required_space.get("str", 0)),
                },
            }
        )

        # Reconstruct constants
        constants = self.constant_table.constants
        if constants:
            for address, constant in constants.items():
                self.memory_manager.set_memory(index=address, value=constant.value)

    def translate_program(self, file_name):
        """
        Translates a QuackScript program from an object file
        """
        if not os.path.exists(file_name):
            print(f"File {file_name} does not exist.")
            return

        data = self.read_and_delete_object_files(file_name)

        self.quadruples = data["quadruples"]
        self.operators = data["operators"]
        self.functions = data["functions"]
        self.constant_table = data["constants_table"]
        self.global_container_name = data["global_container_name"]

        self.reconstruct_memory()

        print(self.memory_manager.get_memory(12000))

        self.process_quadruples()


if __name__ == "__main__":
    qvm = QuackVirtualMachine()
